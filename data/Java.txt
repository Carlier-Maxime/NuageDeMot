Java est un langage de programmation orienté objet créé par James Gosling et Patrick Naughton,
employés de Sun Microsystems, avec le soutien de Bill Joy (cofondateur de Sun Microsystems en 1982),
présenté officiellement le 23 mai 1995 au SunWorld.

La société Sun a été ensuite rachetée en 2009 par la société Oracle qui détient et maintient désormais Java.

Une particularité de Java est que les logiciels écrits dans ce langage sont compilés vers une représentation
binaire intermédiaire qui peut être exécutée dans une machine virtuelle Java (JVM) en faisant abstraction du
système d'exploitation.


Aperçu

Le langage Java reprend en grande partie la syntaxe du langage C++.
 Néanmoins, Java a été épuré des concepts les plus subtils du C++ et à la fois les plus déroutants,
 tels que les pointeurs et références, ou l’héritage multiple contourné par l’implémentation des interfaces.
 De même, depuis la version 8, l'arrivée des interfaces fonctionnelles introduit
 l'héritage multiple (sans la gestion des attributs) avec ses avantages et inconvénients tels que l'héritage en diamant.
 Les concepteurs ont privilégié l’approche orientée objet de sorte qu’en Java, tout est objet à l’exception
 des types primitifs (nombres entiers, nombres à virgule flottante, etc.) qui ont cependant leurs variantes
 qui héritent de l'objet Object (Integer, Float, ...).

Java permet de développer des applications client-serveur.
Côté client, les applets sont à l’origine de la notoriété du langage.
C’est surtout côté serveur que Java s’est imposé dans le milieu de l’entreprise grâce aux servlets,
le pendant serveur des applets, et plus récemment les JSP (JavaServer Pages) qui peuvent se substituer à PHP,
ASP et ASP.NET.

Java a donné naissance à un système d'exploitation (JavaOS), à des environnements de développement (eclipse/JDK),
 des machines virtuelles (MSJVM (en), JRE) applicatives multiplate-forme (JVM),
 une déclinaison pour les périphériques mobiles/embarqués (J2ME),
 une bibliothèque de conception d'interface graphique (AWT/Swing),
 des applications lourdes (Jude, Oracle SQL Worksheet, etc.),
 des technologies web (servlets, applets) et une déclinaison pour l'entreprise (J2EE).
 La portabilité du bytecode Java est assurée par la machine virtuelle Java,
 et éventuellement par des bibliothèques standard incluses dans un JRE.
 Cette machine virtuelle peut interpréter le bytecode ou le compiler à la volée en langage machine.
 La portabilité est dépendante de la qualité de portage des JVM sur chaque OS.

Historique

Origine du langage

Le langage Java est issu d’un projet de Sun Microsystems datant de 1990 :
l’ingénieur Patrick Naughton n’était pas satisfait par le langage C++ utilisé chez Sun,
ses interfaces de programmation en langage C, ainsi que les outils associés. Alors qu’il envisageait une migration
vers NeXT, on lui proposa de travailler sur une nouvelle technologie et c’est ainsi que le Projet Stealth (furtif)
vit le jour.

Le Projet Stealth fut rapidement rebaptisé Green Project avec l’arrivée de James Gosling et de Mike Sheridan. Ensemble,
aidés d’autres ingénieurs, ils commencèrent à travailler dans un bureau de la rue Sand Hill à Menlo Park en Californie.
Ils essayèrent d’élaborer une technologie pour le développement d’applications d’une nouvelle génération,
offrant à Sun la perspective d’opportunités uniques.

L’équipe envisageait initialement d’utiliser le langage C++,
mais l’abandonna pour différentes raisons. Tout d’abord, ils développaient sur un système embarqué avec
des ressources limitées et estimaient que l’utilisation du C++ demandait un investissement trop important et que
cette complexité était une source d’erreur pour les développeurs. L'absence de ramasse-miettes impliquait que la gestion
de la mémoire devait être programmée manuellement, un défi mais aussi une source d’erreurs.

L’équipe était également insatisfaite des lacunes du langage C++ au niveau de la sécurité,
de la programmation distribuée, du multi-threading. De plus, ils voulaient une plate-forme qui puisse être portée
sur tout type d’appareils ou de plates-formes.

Bill Joy avait envisagé un nouveau langage combinant le meilleur du langage de programmation Mesa (en) et du langage C.
Dans un article appelé Plus loin (Further), il proposa à Sun que ses ingénieurs développent
un environnement orienté objet basé sur le langage C++. À l’origine, Gosling envisageait de modifier et
d’améliorer le langage C++, qu’il appelait C++ ++ --, mais l’idée fut bientôt abandonnée au profit
du développement d’un nouveau langage de programmation qu’ils appelèrent Oak (chêne) en référence, selon la légende,
à un arbre planté devant la fenêtre de leur bureau[réf. souhaitée].

L’équipe travailla avec acharnement[réf. souhaitée] et, à l’été 1992,
ils furent capables de faire une démonstration constituée d'une plate-forme incluant le système d’exploitation
Green[réf. souhaitée], le langage Oak (1992), les bibliothèques et le matériel. Leur première réalisation,
présentée le 3 septembre 1992, fut la construction d’un PDA appelé Star7 ayant une interface graphique et
un agent intelligent appelé Duke pour prêter assistance à l’utilisateur.

En novembre de la même année, le Green Project fut abandonné pour devenir FirstPerson, Inc,
appartenant en totalité à Sun Microsystems et l’équipe fut relocalisée à Palo Alto. L’équipe FirstPerson était
intéressée par la construction d’outils hautement interactifs et quand Time Warner publia un appel d’offres en faveur
d’un décodeur multifonctions, FirstPerson changea d’objectif pour proposer une telle plate-forme.

Cependant, l’industrie de la télévision par câble trouva qu’elle offrait trop de possibilités à l’utilisateur et
FirstPerson perdit le marché au profit de Silicon Graphics. Incapable d’intéresser l’industrie audiovisuelle,
la société fut réintégrée au sein de Sun.

Java rencontre Internet

De juin à juillet 1994, après trois jours de remue-méninges avec John Gage, James Gosling, Joy, Naughton, Wayne Rosing
et Eric Schmidt, l’équipe recentra la plate-forme sur le web. Ils pensaient qu’avec l’avènement du navigateur Mosaic,
Internet était le lieu où allait se développer le même genre d’outil interactif que celui qu’ils avaient envisagé pour
l’industrie du câble. Naughton développa comme prototype un petit navigateur web, WebRunner qui deviendra par la suite
HotJava.

La même année le langage fut renommé Java après qu’on eut découvert que le nom Oak était déjà utilisé par un fabricant
de carte vidéo.

Origine du nom Java

Le nom « Java » n'est pas un acronyme, il a été choisi lors d'un brainstorming4 en remplacement du nom d'origine «Oak»,
à cause d'un conflit avec une marque existante, parce que le café (« java » en argot américain)5 est la boisson favorite
de nombreux programmeurs6. Le logo choisi par Sun est d'ailleurs une tasse de café fumant.

Lancement public de Java

En octobre 1994, HotJava et la plate-forme Java furent présentés pour Sun Executives. Java 1.
0a fut disponible en téléchargement en 1994 mais la première version publique du navigateur HotJava arriva
le 23 mai 1995 à la conférence SunWorld7.

L’annonce fut effectuée par John Gage, le directeur scientifique de Sun Microsystems. Son annonce fut accompagnée de l’annonce surprise de Marc Andressen, vice-président de l’exécutif de Netscape que Netscape allait inclure le support de Java dans ses navigateurs. Le 9 janvier 1996, le groupe Javasoft fut constitué par Sun Microsystems pour développer cette technologie8. Deux semaines plus tard la première version de Java était disponible.

Avènement de Java 2

L'apparition de la version 1.2 du langage marque un tournant significatif : c'est en 2000 qu'apparait simultanément la déclinaison en deux plateformes Java :

    Java 2 Standard Edition (J2SE), plateforme avec les API et bibliothèques de bases, devenue depuis Java SE ;
    Java 2 Enterprise Edition (J2EE), extension avec des technologies pour le développement d'applications d’entreprise, devenue Java EE.

Sun les qualifie alors de plateforme Java 2 par opposition aux premières générations 1.0 et 1.1. Toutes les versions ultérieures, de J2EE 1.2 à Java SE ou Java EE 7 restent désignées sous le qualificatif de plateformes Java 2, bien que le '2' ait été depuis officiellement abandonné.
Histoire récente
Utilisation Web
Côté client

Applets

Historiquement, la possibilité des navigateurs Web de lancer des applets Java était la seule solution pour afficher
des applications clientes riches (RIA pour rich Internet application).
Puis des technologies concurrentes ont émergé parmi lesquelles Macromedia Flash,
le DHTML JavaScript, Silverlight basé sur XAML ou Xul.

Les applets sur le poste Client peuvent communiquer avec des servlets sur le Serveur,
tout comme Javascript peut communiquer avec le Serveur au moyen d’AJAX.
Flex utilise quant à lui la technologie Flash par le biais du Adobe Flash Player.

À une époque où JavaScript souffrait de problèmes de compatibilité inter-navigateurs,
les applets Java avaient l'avantage de la portabilité car le portage d'interfaces complexes était difficile à
assurer pour tous les navigateurs du marché.

Outre la retombée de la « mode » Java,
les progrès faits dans les technologies concurrentes à Java ont amené la plupart des développeurs à se détourner
des applets Java et des problèmes inhérents à cette technologie (incompatibilités entre les JVM, mauvaises performances,
pauvreté des bibliothèques graphiques, complexité). Enfin, les navigateurs modernes n'incluent plus systématiquement
l'environnement Java à cause de sa taille importante, et le taux de machines capables d'afficher des applets
n'était plus que de 70 % en 2010, bien plus faible que pour Flash par exemple9. En 2010,
la quasi-totalité des applications clients riches utilisent des technologies alternatives ;
Flash pour l'essentiel mais aussi GWT.

Enfin, l'arrivée de HTML5, destiné à embarquer de nombreuses fonctionnalités RIA et multimédia,
rend également les applets caducs.

JavaFX

Avec l'apparition de Java 8 en mars 2014,
JavaFX devient l'outil de création d'interface graphique ('GUI toolkit') officiel de Java, pour toutes les sortes
d'application (applications mobiles, applications sur poste de travail, applications Web…),
le développement de son prédécesseur Swing étant abandonné (sauf pour les corrections de bogues).
JavaFX est une pure API Java (le langage de script spécifique qui lui a été un temps associé est maintenant abandonné).
JavaFX contient des outils très divers, notamment pour les médias audio et vidéo, le graphisme 2D et 3D,
la programmation Web, la programmation parallèle, etc.

Côté serveur

Avec les serveurs d’applications, on utilise des EJB pour encapsuler les classes définies précédemment.
Ces éléments sont utilisés dans des architectures J2EE pour des applications multicouches.
L'avantage qu'on tire de ce travail est de pouvoir cacher au client l'implémentation du code côté serveur.

Utilisation sur poste de travail
L’utilisation native du langage Java pour des applications sur un poste de travail restait jusqu'à présent relativement
rare à cause de leur manque de rapidité. Cependant, avec l’accroissement rapide de la puissance des ordinateurs,
les améliorations au cours des années 2000, de la machine virtuelle Java et de la qualité des compilateurs,
plusieurs technologies ont gagné du terrain comme NetBeans et l’environnement Eclipse,
les technologies de fichiers partagés LimeWire, Vuze (ex Azureus), et I2P. Java est aussi utilisé dans
le programme de mathématiques MATLAB, au niveau de l’interface homme machine et pour le calcul formel.
Les applications Swing apparaissent également comme une alternative à la technologie .NET.

Utilisation avec les mobiles

Oracle annonce début octobre 2012 à la conférence JavaOne sa volonté de proposer des solutions Java pour le domaine
des logiciels embarqués, pour processeurs moins puissants que ceux habituellement disponibles sur les PC.
Oracle fédère autour d'elle tout un écosystème d'entreprises spécialistes de ces segments de marchés, comme l'éditeur
MicroEJ10 ou encore STMicroelectronics qui propose du Java sur ses STM3211 dont le cœur est un CortexM3/M4.

Java, notamment via Eclipse et NetBeans, offre déjà des environnements de développement intégrés pour mobile.
Java est le principal langage utilisé pour développer des applications pour le système d'exploitation libre pour
Mobile de Google : Android.

JavaFX peut aussi permettre l'utilisation de Java sur mobiles, bien que ce ne soit pas son objectif principal.
OS Windows, Mac OS X et GNU/Linux

Microsoft a fourni en 2001 un environnement de travail de type Java, dénommé J++, avec ses systèmes d’exploitation
avant la sortie de Windows XP. À la suite d'une décision de justice[réf. nécessaire], et au vu du non-respect
des spécifications de ce langage, Microsoft a dû abandonner celui-ci et créer un nouveau langage,
de nom C# (cf. chapitre « Indépendance vis-à-vis de la plate-forme » plus bas)

Beaucoup de fabricants d’ordinateurs continuent d’inclure un environnement JRE sur leurs systèmes Windows.

Java apparaît également comme un standard au niveau du Mac OS X d’Apple aussi bien que pour les distributions Linux.
Ainsi, de nos jours, la plupart des utilisateurs peuvent lancer des applications Java sans aucun problème. Toutefois,
sur ordinateur Apple, la distribution de Java 5 à Java 6 fut assurée directement par Apple, et non par Oracle12.
Cette politique entraîna des retards et des restrictions de version :

Ainsi J2SE 1.4 ne fut pas disponible avant Mac OS X v10.2 (nom de code Jaguar),
J2SE 5.0 à partir de Mac OS X v10.4 (Tiger), Java SE 6 fonctionne uniquement sous Mac OS X v10.5 (Leopard) équipé de
processeur Intel13, et Java 7 exige un ordinateur Mac Intel exécutant la version Mac OS X v10.7.3 (Lion).

Passage sous licence open-source

Le 11 novembre 2006, le code source du compilateur javac et de la machine virtuelle HotSpot ont été publiés en
Open Source sous la Licence publique générale GNU14.

Le 13 novembre 2006, Sun Microsystems annonce le passage de Java, c’est-à-dire le JDK (JRE et outils de développement)
et les environnements Java EE (déjà sous licence CDDL) et Java ME sous licence GPL d’ici mars 2007,
sous le nom de projet OpenJDK15.

En mai 2007, Sun publie effectivement OpenJDK sous licence libre. Cependant OpenJDK dépend encore de fragments de code
non libre que Sun ne détient pas. C'est pourquoi la société Redhat lance en juin 2007 le projet IcedTea (en) qui vise à
remplacer les fragments de code non libre et ainsi rendre OpenJDK utilisable sans aucun logiciel propriétaire.
En juin 2008, le projet IcedTea a passé les tests rigoureux de compatibilité Java (TCK)16. IcedTea est donc une
implémentation open-source des spécifications de Java. Sun, puis Oracle, garde toutefois le contrôle de la technologie
par le biais d'un catalogue de brevets s'appliquant à Java, ainsi que par le maintien du TCK sous une licence
propriétaire.

Acquisition par Oracle

La société Oracle a acquis en 2009 l'entreprise Sun Microsystems.
On peut désormais voir apparaître le logo Oracle dans les documentations de l'api Java.

Le 12 avril 2010, James Gosling, le créateur du langage de programmation Java, démissionne d’Oracle pour des motifs
qu’il ne souhaite pas divulguer. Il était devenu le directeur technologique de la division logicielle client
pour Oracle.

En 2018, Oracle annonce que les mises à jour de sa version Java SE 8 pour un usage professionnel seraient soumis à
une licence payante à partir de janvier 201917.

Historique des versions

Le langage Java a connu plusieurs évolutions depuis le JDK 1.0 (Java Development Kit) avec l’ajout de nombreuses classes
et packages à la bibliothèque standard. Depuis le J2SE1.4, l’évolution de Java est dirigée par
le JCP (Java Community Process) qui utilise les JSR (Java Specifications Requests) pour proposer des ajouts
et des changements sur la plate-forme Java. Le langage lui-même est spécifié par le JLS (Java Language Specification),
les modifications du JLS étant gérées sous le code JSR 90118.

Il faut noter que les évolutions successives du langage ne portent guère sur sa syntaxe -relativement stable depuis
le début- mais principalement sur l'enrichissement de ses fonctions, avec l'embarquement et l'optimisation de
bibliothèques logicielles (API) dans des domaines très variés de l'informatique : bases de données, gestion XML,
informatique distribuée et web, multimédia, sécurité…

Numérotation des versions

Il faut distinguer la version du langage Java de celles des plateformes et du JRE :

    Le numéro majeur de version du langage (par exemple Java 5) spécifiée par le JLS,
    est ainsi le numéro mineur pour le JRE ou la plateforme (par ex JRE 1.5 ou Java SE 1.5)19 ;
    Le JRE et la plateforme Java SE sont eux identifiés depuis Java 5 par un même numéro de version :
    ainsi Java SE 1.6.0.43, et le JRE 1.6.0.43, sont tous deux conformes au langage Java 6,
    mais ont fait l'objet notamment de correctifs de sécurité20 ;
    Java FX (orienté RIA), constitué essentiellement d'un sous-ensemble de JavaSE,
    suit également le même numéro de version : Java FX en est ainsi sa version 2.7 pour
    1.721(également compatible JRE 1.6) ;
    En revanche, les plateformes Enterprise Edition (Java EE) et Mobile Edition (Java ME) sont identifiées par le
    numéro de version de leur propre SDK ; ainsi début 2013 :
        Java EE en était encore à la version 6 (Java EE 6 SDK Update 4),
        mais fonctionnait avec les JDK 6 ou 722; il n'est réellement passé à Java 7 que mi-juin 201323,
        Java ME en est à sa version 3.3 (SDK v. 3.3)24.

Versions successives

Deux versions peuvent parfois être proposées simultanément, telles que 8u65 & 8u66 :
la différence consiste généralement en des corrections de bugs mineurs (sans incidence de sécurité notamment),
pour lesquelles la mise à jour à la toute dernière version n'est pas critique et est de ce fait laissée au choix
des administrateurs (JRE) ou développeurs (JDK).

Les versions publiques de Java peuvent être suivies de versions non publiques, dites Advanced, réservées à des
usages commerciaux ; ainsi Java 1.6u45 est la dernière version publique de Java6, mais 6u113 l'ultime version disponible
fin mars 2016.

Seules les derniers numéros de versions de chaque release sont listées ici.
Le détail des modifications successives par version et par update figure sur wikipedia.en/java_history.
Contenu et évolutions Du JDK 1.0 au J2SE 1.4

    JDK 1.0 (23 janvier 1996 - 211 classes et interfaces) — Version initiale33.
    JDK 1.1 (19 février 1997 - 477 classes et interfaces) — De nombreux ajouts34 avec notamment :
        une refonte complète du modèle événementiel AWT.
        Les classes internes sont ajoutées au langage.
        JavaBeans.
        JDBC.
        Java Remote Invocation (RMI).
    J2SE 1.2 (9 décembre 1998 - 1 524 classes et interfaces) — Nom de code Playground.
    Cette version et les suivantes jusque J2SE 7.0 sont rebaptisées Java 2 et la version nommée
    J2SE (Java 2 Platform, Standard Edition) remplace JDK pour distinguer la plate-forme de base de la version
    J2EE (Java 2 Platform, Enterprise Edition) et de la version J2ME (Java 2 Platform, Micro Edition).
    Plusieurs ajouts35 dont :
        le mot-clé strictfp (strict floating-point : virgule flottante stricte)
        la réflexion
        l’API graphique Swing est intégrée.
        Pour la première fois, la machine virtuelle Java de Sun inclut un compilateur
        « Compilation à la volée » (Just in Time).
        Java Plug-in
        Java IDL, une implémentation de IDL pour l’interopérabilité avec CORBA.
        le framework Collections.
    J2SE 1.3 (8 mai 2000 - 1 840 classes et interfaces) — Nom de code Kestrel. Changements principaux36 :
        HotSpot JVM inclus (La machine virtuelle HotSpot sortit en avril 1999 pour la machine virtuelle du J2SE 1.2)
        Changement pour les RMI pour être basé sur CORBA.
        JavaSound
        JNDI (Java Naming and Directory Interface) inclus de base (disponible auparavant comme extension)
        JPDA (Java Platform Debugger Architecture)
    J2SE 1.4 (6 février 2002 - 2 723 classes et interfaces) — Nom de code Merlin. Ce fut la première révision de
    la plate-forme sous JCP (Java Community Process)37. Les principaux changements38 sont :
        le mot-clé assert (Spécifié dans JSR 4139.)
        les expressions rationnelles modélisées en s’inspirant du langage Perl.
        Le chaînage d’exception permet à une exception d’encapsuler l’exception de bas niveau d’origine.
        (Spécifié dans (en) JSR 51 [archive].)
        API de journalisation (Spécifiée dans (en) JSR 47 [archive].)
        l’API Image I/O pour lire et écrire des images dans des formats comme JPEG et PNG.
        intégration d’un parser XML et du moteur XSLT nommé JAXP (Spécifié dans (en) JSR 5 [archive]
        et (en) JSR 63 [archive].)
        intégration des extensions de sécurité JCE (Java Cryptography Extension (en)), JSSE et JAAS.
        Java Web Start (introduit pour la première fois en mars 2001 pour J2SE 1.3 - Spécifié dans
        (en) JSR 56 [archive].)

J2SE 5.0

Sortie le 30 septembre 2004 (3 270 classes et interfaces), son nom de code est Tiger.
Elle est initialement numérotée 1.5, qui est toujours utilisé comme numéro de version interne40.
Développé par (en) JSR 176 [archive], Tiger ajoute un nombre significatif de nouveautés41 au langage :

    Intégration du composant logiciel Java Web Start dans l'environnement d'exécution Java (JRE)42
    Programmation générique — (Spécifié par (en) JSR 14 [archive])
    Metadata — également appelées annotations, permet au langage de construire des classes et des méthodes étiquetées
    avec des données additionnelles qui peuvent être utilisées en tant que
    méta-données (Spécifiée dans (en) JSR 175 [archive].)
    Autoboxing/unboxing — conversion automatique entre des types primitifs (comme le type int) et le Wrapper de classe
    correspondant (comme la classe Integer) (Spécifié dans (en) JSR 201 [archive]).
    Énumérations — le mot-clé enum permet de créer une liste ordonnée de valeurs en gardant la sûreté du typage.
    Auparavant, ceci pouvait seulement être réalisé par des entiers constants (Spécifié dans JSR 201).
    Varargs — la syntaxe Object… utilisée dans une déclaration de méthode permet de spécifier un nombre variable
    d’arguments pour cette méthode. C’est un fonctionnement équivalent à la fonction « printf » en C.
    Imports statiques — Cette fonctionnalité permet d’utiliser les constantes d’une classe sans spécifier le nom de
    cette classe et sans passer par « l’anti-pattern Constant Interface »
    (c’est l’expression utilisée sur le site de Sun).
    Extension du for pour les boucles — la syntaxe du for est étendue avec une syntaxe spéciale pour itérer sur
    n’importe quel objet itérable comme un tableau, ou une collection en utilisant la syntaxe :

        void displayWidgets (Iterable<Widget> widgets) {
            for (Widget w : widgets) {
                w.display();
            }
        }

Cet exemple parcourt le contenu de l’objet widgets de la classe Iterable et contenant uniquement des références vers
des objets de la classe Widget, assignant chacun de ces éléments à la variable w et ensuite appelle la méthode display()
sur l’élément w (spécifié dans JSR 201). Une syntaxe similaire sera introduite en 2011 dans C++11.

En plus des changements au niveau du langage, des changements plus importants ont eu lieu au fil des années qui ont
conduit des quelques centaines de classes dans le JDK 1.0 à plus de 3 000 dans J2SE 5.0. Des API entières,
comme Swing ou Java2D, ont été ajoutées et beaucoup de méthodes de l’original JDK 1.0 ont été déclarées deprecated
(c’est-à-dire déconseillées, elles pourraient être supprimées dans une version ultérieure de Java).

Java SE 6

Sortie le 11 décembre 2006 (3 777 classes et interfaces dans plus de 20 paquetages),
son nom de code est Mustang [archive]43. Une version bêta est sortie le 15 février 2006, une autre bêta en juin 2006,
une version « release candidate » en novembre 2006, et la version finale le 12 décembre 2006. Avec cette version,
Sun remplace définitivement le nom J2SE par Java SE et supprime le .0 au numéro de version44.

Cette version a été l'objet de nombreuses failles de sécurité et leurs mises à jour correctives,
conduisant à la version 1.6.0_45 par Oracle et même 1.6.0_51 pour sa version Mac OS. C'est d'ailleurs là la
dernière version de Java fonctionnant pour Mac OS X 10.6 et antérieurs.

Java SE 7

Sortie le 7 juillet 2011 (8 00045 classes et interfaces), son nom de code est Dolphin.
Il s’agit de la première version sous la licence GNU GPL.

Dès l'update 6 (7u6), l'édition standard Oracle de Java supportant de nouveau pleinement Mac OS X46,
les mises à jour pour cet OS ne sont plus prises en charge par Apple mais par Oracle. Toutefois cette version de Java
n'est pas supportée par Mac OS X v10.6 : En effet certaines API requises par Java 7 ont bien été incluses par Apple
dans Mac OS X 10.7.3, mais il n'est pas prévu qu'elles soient implémentées sur les précédentes versions de Mac OS47.
La version 7u90 d'avril 2015 est la dernière mise à jour de Java 7 disponible publiquement48.

Java 7 propose entre autres les nouveautés suivantes :

    la notation binaire ;
    le formatage numérique pour plus de lisibilité ;
    les switch avec des string ;
    l'inférence des types à la création d'instance pour éviter une redondance de syntaxe
    (cf. List<String> lst = new ArrayList<>();) ;
    le multicatch permettant de concaténer les exceptions catchées via des | ;
    java.nio (JSR 203) qui propose notamment une nouvelle interface Path, un système de parcours des répertoires,
    un service de watch…
    les tasks pour paralléliser les calculs jugés trop lourd ou trop coûteux ;
    l'autoboxing d'objets vers les types primitifs ;
    interface utilisateur : transparence des frames, bordures arrondies,
    gestion des évènements asynchrones via les secondary loops, les JLayers, les Painters, le nouveau style Nimbus…

Java SE 8

Nom de code Kenaï.
Diverses releases en cours de développement du JDK sont disponibles au téléchargement dès l'automne 201349,
et Java 8 sort mi-mars 2014 conformément à une feuille de route présentée par Oracle dès mai 201350.

Une des nouveautés majeures de cette version est l’ajout des lambdas51,
entraînant une refonte d'une partie de l'API, notamment les collections et la notion de stream.
Les autres ajouts notables incluent les optionnels, les implémentations par défaut au sein d'une interface,
une refonte de l'API date, etc. En revanche la version Enterprise Edition (Java 8 EE) n'est pas attendue avant 2017.

La modularisation de la JVM avec le projet Jigsaw,
initialement prévue pour cette version, est quant à elle reportée à la version 952,
du fait notamment des failles de sécurité rencontrées par Java 6 dont Oracle a privilégié la correction en 2013
par rapport aux évolutions de Java.

Java SE 9

Initialement prévue pour 2015 mais reportée en partie à cause du projet Jigsaw, cette version est finalement
sortie le 21 septembre 201753.

Java 9 intègre :

    le projet Jigsaw permettant de modulariser les modules chargés au sein du JDK ;
    le projet Kulla visant la création d'un shell pour Java sur le format read–eval–print loop (en) ;
    le projet Valhalla visant une amélioration des types Java ;
    un support natif du format JSON et de HTTP/254.

Java SE 10

Cette version est sortie le 20 mars 201855.

Cette nouvelle version intègre notamment :

    JEP 28656 : inférence des types des variables locales;
    JEP 31057 : partage de binaire pour permettre un lancement plus rapide
    JEP 31758 : activation de Graal un compilateur JIT en Java

Java SE 11

Cette version est sortie le 25 septembre 201859.

Au-delà du changement du modèle de support à long terme des versions, cette version intègre notamment :

    JEP 323 : amélioration sur les paramètres des lambda
    JEP 321: un client HTTP plus évolué
    JEP 320 : suppression des modules CORBA et EE par défaut

Java SE 12

Cette version est sortie le 19 mars 201960.

Cette version intègre 8 évolutions :

    JEP 189 : Shenandoah, un ramasse miette avec de courte pauses (Expérimentale)
    JEP 230 : suite d'outils de microbenchmark pour le code source du JDK
    JEP 325 : expressions Switch (aperçu)
    JEP 334 : API Constants, permettant d'ajouter des informations dans les métadonnées dans les fichiers .class,
    utile pour les langages sur la JVM)
    JEP 340 : un seul portage pour l'architecture ARM 64bits
    JEP 341 : Default CDS Archives, chargement des informations des classes de la JVM plus rapide
    JEP 344 et JEP 346 : améliorations du ramasse miette G1

Java SE 13

Cette version est sortie le 17 septembre 201961.

    JEP 355: Text Blocks
    JEP 354: (Switch) Nouveau case case...-> (case traditionnel case...:)

    switch(nombre){
        //case traditionnel
        case 5:
            System.out.println("La variable est égale à 5");
            break;

        //nouveau case
        case 5 -> System.out.println("La variable est égale à 5");
    }

Java SE 14

Cette version est sortie le 17 mars 202062

    JEP 343: Incubator

    JEP 358: Plus de précision de la part du compilateur sur les erreurs NullPointerExceptions
    JEP 361: (Switch) Nouveau case case...-> (case traditionnel case...:)
    JEP 362: Dépréciation des ports Solaris et SPARC
    JEP 368: Text Blocks

Java SE 15

Cette version est sortie le 15 septembre 202063.
Java SE 16

Cette version est sortie le 16 mars 202164.
Java SE 17

Cette version est sortie le 14 septembre 202165.

    JEP 306: Restauration de la sémantique stricte permanente pour la virgule flottante
    JEP 356: Générateur amélioré de nombre pseudo-aléatoire
    JEP 382: Nouveau pipeline de rendu macOS
    JEP 391: Portage macOS AArch64 Dépréciation pour suppression de l'API Applet
    JEP 398: Dépréciation pour suppression de l'API Applet
    JEP 403: Encapsulation forte des internes du JDK
    JEP 406: Filtrage par motif (Pattern Matching) pour switch (préversion)
    JEP 407: Suppression de l'activation de RMI
    JEP 409: Classes scellées
    JEP 410: Suppression du compilateur expérimental AOT et JIT
    JEP 411: Dépréciation pour suppression du gestionnaire de sécurité
    JEP 412: API de fonction étrangère et de mémoire (incubation)
    JEP 414: API vectorielle (deuxième incubation)
    JEP 415: Filtres de désérialisation spécifiques au contexte

Philosophie

Lors de la création du langage Java, il avait été décidé que ce langage devait répondre à cinq objectifs66 :

    simple, orienté objet et familier ;
    robuste et sûr ;
    indépendant de la machine employée pour l'exécution ;
    très performant ;
    compilé, multi-tâches et dynamique.

Langage orienté objet et familier
Article connexe : Programmation orientée objet.

La première caractéristique, le caractère orienté objet (« OO ») et familier, fait référence à une méthode
de programmation et de conception du langage et le fait qu'un programme écrit en Java ressemble assez fort
à un programme écrit en C++.

Bien qu’il existe plusieurs interprétations de l’expression orienté objet,
une idée phare dans ce type de développement est que les différents types de données doivent être directement associés
avec les différentes opérations qu’on peut effectuer sur ces données. En conséquence, les données (appelées Propriétés)
et le code les manipulant (appelé Méthodes) sont combinés dans une même entité appelée Classe d'objet.
Le code devient logiquement découpé en petites entités cohérentes et devient ainsi plus simple à maintenir et plus
facilement réutilisable, étant intrinsèquement modulaire.

D’autres mécanismes tels que l’héritage permettent d’exploiter toutes les caractéristiques d’une Classe
précédemment écrite dans ses propres programmes sans même avoir à en connaître le fonctionnement interne — on n’en voit
que l’interface (l'interface décrit les propriétés et les méthodes sans fournir le code associé).
Java interdit la notion d'héritage depuis plusieurs classes parent sauf si elles sont des interfaces.

Dans la version 1.5 du langage ont été rajoutés les génériques, un mécanisme de polymorphisme similaire (mais différent)
aux templates du langage C++ ou aux foncteurs d’OCaml. Les génériques permettent d’exprimer d’une façon plus simple
et plus sûre (du point de vue du typage) les propriétés d’objets comme des conteneurs (listes, arbres…) :
le type liste est alors considéré génériquement par rapport au type d’objet contenu dans la liste.

Mécanisme du ramasse-miettes

Article connexe : Ramasse-miettes en informatique.

Cet élément contribue à la robustesse et à la performance des programmes, le ramasse-miettes (Garbage Collector) est
appelé régulièrement et automatiquement pendant l'exécution du programme.
Sur les systèmes multi-processeurs et/ou multi-cœurs, celui-ci emploie même des threads multiples à faible priorité afin
de perturber le moins possible l'exécution du programme67. En outre, le programmeur peut au besoin suggérer de lancer
le ramasse-miettes à l’aide de la méthode System.gc().

Un grief récurrent à l’encontre de langages comme C++ est la lourde tâche d’avoir à programmer manuellement la gestion
de la mémoire. En C++, la mémoire allouée par le programme pour créer un objet est désallouée lors de la destruction de
celui-ci (par exemple par un appel explicite à l'opérateur delete). Si le programmeur oublie de coder la désallocation,
ceci aboutit à une « fuite mémoire », et le programme en consomme de plus en plus. Pire encore,
si par erreur un programme demande plusieurs fois une désallocation, ou emploie une zone de mémoire après avoir demandé
sa désallocation, celui-ci deviendra très probablement instable et causera une erreur fatale.

En Java, une grande partie de ces problèmes est évitée grâce au ramasse-miettes. L'espace mémoire nécessaire à chaque
objet créé est géré dans un tas de mémoire (en anglais : memory heap) réservé à cet usage. Le programme accéde à chaque
objet via une référence dans le tas. Quand il n'existe plus aucune référence permettant d'atteindre un objet,
le ramasse-miettes le détruit automatiquement — puisqu'il est devenu inaccessible — libérant la mémoire
et prévenant ainsi toute fuite de mémoire.

Le ramasse-miettes emploie un algorithme de marquage puis libération (en anglais : mark and sweep67) qui permet de gérer
les cas complexes d'objets se référençant mutuellement ou de boucles de références
(cas d'une liste à chaînage double par exemple).
En pratique, il subsiste des cas d'erreur de programmation où le ramasse-miettes considère qu'un objet est encore utile
alors que le programme n'y accède plus fonctionnellement (mais garde une référence sur l'objet), ce qui constitue
un cas particulier de « fuite mémoire ».

Le ramasse-miettes rend sensiblement plus simple et plus sûre la gestion de la mémoire. Les concepteurs et
les utilisateurs de programmes ou bibliothèques (en anglais Libraries) n'ont pas à se soucier de la désallocation
des objets (opérateur delete en C++), sauf éventuellement pour des raisons de performance.

Indépendance vis-à-vis de la plate-forme

Articles connexes : Bytecode Java et Compilation à la volée.

L’indépendance vis-à-vis de la plate-forme signifie que les programmes écrits en Java fonctionnent de manière
parfaitement similaire sur différentes architectures matérielles. La licence de Sun pour Java insiste ainsi sur le fait
que toutes les implémentations doivent être compatibles. On peut ainsi théoriquement effectuer le développement sur une
architecture donnée et faire tourner l’application finale sur toutes les autres.

Ce résultat est obtenu par :

    des bibliothèques standard fournies pour pouvoir accéder à certains éléments
    de la machine hôte (le graphisme, le multithreading, la programmation réseau…)
    exactement de la même manière sur toutes les architectures ;
    des compilateurs Java qui compilent le code source « à moitié » afin d’obtenir
    un bytecode (plus précisément le bytecode Java, un langage de type assembleur, proche de la machine virtuelle
    et spécifique à la plate-forme Java).

    Ce bytecode a ensuite vocation à être interprété sur une machine virtuelle Java (JVM en anglais),
    un programme écrit spécifiquement pour la machine cible qui interprète le bytecode Java et fait exécuter par
    la machine les instructions traduites en code natif.

Noter que même s’il y a explicitement une première phase de compilation, le bytecode Java est soit interprété,
soit converti à la volée en code natif par un compilateur à la volée (just in time, JIT).

Types de compilations

Les premières implémentations du langage utilisaient une machine virtuelle interprétée pour obtenir la portabilité.
Ces implémentations produisaient des programmes qui s’exécutaient plus lentement que ceux écrits
en langage compilé (C, C++, etc.) si bien que le langage souffrit d’une réputation de faibles performances.

Des implémentations plus récentes de la machine virtuelle Java (JVM) produisent des programmes beaucoup plus rapides
qu’auparavant, en utilisant différentes techniques :

    La première technique est de compiler directement en code natif comme un compilateur traditionnel,
    supprimant complètement la phase de bytecode. Des compilateurs Java tels que GNU Compiler for Java (GCJ)
    compilent ainsi directement le Java en code objet natif pour la machine cible.
    On obtient ainsi de bonnes performances, mais aux dépens de la portabilité : le code final produit par
    ces compilateurs ne peut de ce fait être exécuté que sur une seule architecture ;
    Une autre technique appelée compilation « juste-à-temps », ou « à la volée » (just in time, JIT),
    traduit le byte code en code natif durant la phase de lancement du programme ;
    Certaines machines virtuelles plus sophistiquées utilisent une recompilation dynamique durant laquelle
    la machine virtuelle analyse le comportement du programme et en recompile sélectivement certaines parties.
    La recompilation dynamique permet d’obtenir de meilleurs résultats que la compilation statique car
    les compilateurs dynamiques peuvent optimiser en fonction de leur connaissance de l’environnement cible
    et des classes qui sont utilisées.

    La compilation JIT et la recompilation dynamique permettent à Java de tirer profit de la rapidité du code natif
    sans perdre la portabilité.

Bilan de la portabilité Java

Après que Sun eut constaté que l’implémentation de Microsoft ne supportait pas les interfaces RMI et JNI,
et comportait des éléments spécifiques à certaines plates-formes par rapport à sa plate-forme initiale,
Sun déposa plainte en justice contre Microsoft68, et obtint des dommages et intérêts (20 millions de dollars).
Cet acte de justice renforça encore les termes de la licence de Sun. En réponse, Microsoft arrêta le support de Java
sur ses plates-formes et, sur les versions récentes de Windows, Internet Explorer ne supporte pas les applets Java
sans ajouter de plug-in. Cependant, Sun met à disposition gratuitement des environnements d’exécution de Java pour
les différentes plates-formes Microsoft.

La portabilité est techniquement un objectif difficile à atteindre et le succès de Java en ce domaine est mitigé.
Quoiqu’il soit effectivement possible d’écrire des programmes pour la plate-forme Java qui fonctionnent correctement
sur beaucoup de machines cibles, le nombre important de plates-formes avec de petites erreurs et des incohérences a
abouti à un détournement du slogan de Sun « Write once, run anywhere » (« Écrire une fois, exécuter n'importe où »)
en « Write once, debug everywhere » (« Écrire une fois, déboguer partout ») !

L’indépendance de Java vis-à-vis de la plate-forme est cependant un succès avec les applications côté serveur comme
les services web, les servlets et le Java Beans aussi bien que les systèmes embarqués sur OSGi, utilisant
l’environnement Embedded Java.

Exécution sécurisée de code distant

La plate-forme Java fut l’un des premiers systèmes à offrir le support de l’exécution du code à partir
de sources distantes. Une applet peut fonctionner dans le navigateur web d’un utilisateur, exécutant du code téléchargé
d’un serveur HTTP. Le code d’une applet fonctionne dans un espace très restrictif, ce qui protège l’utilisateur
des codes erronés ou mal intentionnés. Cet espace est délimité par un objet appelé gestionnaire de sécurité.
Un tel objet existe aussi pour du code local, mais il est alors par défaut inactif.

Le gestionnaire de sécurité (la classe SecurityManager) permet de définir un certain nombre d’autorisations
d’utilisation des ressources du système local (système de fichiers, réseau, propriétés système…).
Une autorisation définit :

    un code accesseur (typiquement, une applet — éventuellement signée — envoyée depuis un serveur web) ;
    une ressource locale concernée (par exemple un répertoire) ;
    un ensemble de droits (par exemple lire/écrire).

Les éditeurs d’applet peuvent demander un certificat pour leur permettre de signer numériquement une applet comme sûre,
leur donnant ainsi potentiellement (moyennant l’autorisation adéquate) la permission de sortir
de l’espace restrictif et d’accéder aux ressources du système local.

Éléments du langage

Voici un exemple d’un programme Hello world typique écrit en Java :

 public class HelloWorld {
     public static void main(String[] args) {
         System.out.println("Hello world!");
     }
 }

Le fichier source porte presque toujours le nom de la classe avec l'extension ".java" (ici "HelloWorld.java",
ce serait même obligatoire car la classe possède l'attribut public dans sa déclaration — la rendant alors accessible à
tout autre programme). On peut compiler puis exécuter cet exemple sur le terminal avec
les commandes suivantes (sous Linux) :

javac HelloWorld.java
export CLASSPATH=.
java HelloWorld

La ligne « export CLASSPATH=. » sert à indiquer à Java qu’il doit également chercher les programmes class dans
le répertoire courant. Ce chemin peut également être spécifié au lancement du programme par l’option -classpath
(ou -cp en abrégé) :

java -cp. HelloWorld

Mots réservés, primitifs et littéraux

abstract else instanceof static try boolean false
assert (1.4) enum (5.0) interface strictfp (1.2) volatile byte true
break extends native super while char
case final new switch double
catch finally package synchronized float
class for private this int
const (*) goto (*) protected throw long
continue if public throws short
default implements return transient void null
do import

Notes :

    (*) ces mots clefs sont réservés mais n'ont pas de signification pour le compilateur (il est juste interdit
    d'employer ce nom pour une variable par exemple) ;
    (1.2), (1.4) et (5.0) ces mots clefs ont été ajoutés avec la version indiquée du langage.

(source [archive])
Classe, attributs, méthodes
Notion de classe

Une classe est la description de données appelées attributs, et d’opérations appelées méthodes. Il s'agit d'un modèle
de définition pour des objets ayant le même ensemble d’attributs, et le même ensemble d’opérations.
À partir d’une classe on peut créer un ou plusieurs objets par instanciation ; chaque objet est une instance
d’une seule classe.

Visibilité :

    Public : le mot class est alors précédé de public, tout utilisateur qui importe le paquetage peut utiliser
    la classe. Dans ce cas elle doit être définie dans un fichier qui a pour nom le nom de la classe.
    Privé : le mot class est alors précédé de private, seules des classes définies dans le même fichier peuvent
    utiliser cette classe.
    Paquetage : le mot class n’est pas précédé de mot particulier, toutes les classes du paquetage peuvent
    utiliser la classe.

Notion d'attribut

Un attribut se définit en donnant son type, puis son nom, et éventuellement une partie initialisation.

Visibilité :

    Public : sa définition est précédée de public, et il peut être utilisé par tout utilisateur de la classe.
    Privé : sa définition est précédée de private, et il ne peut être utilisé qu’à l’intérieur de la classe
    Protégé : sa définition est précédée de protected, et il ne peut être utilisé qu’à l’intérieur de la classe,
    du paquetage, ou des classes dérivées.
    Paquetage : aucun mot particulier ne précède sa définition, ainsi il peut être utilisé dans toute classe
    du même paquetage.

Notion de méthode

Une méthode est définie par :

    Son type de retour : type de la valeur retournée par la méthode. Si la méthode ne retourne pas de valeur
    le type spécifié est alors void.
    Son nom
    Ses paramètres : les paramètres sont spécifiés par leur type et leur nom et sont séparés par des virgules.

Visibilité :

    Public : sa définition est précédée de public, et elle peut être utilisée par tout utilisateur de la classe.
    Privé : sa définition est précédée de private, et elle ne peut être utilisée qu’à l’intérieur de la classe
    Protégé : sa définition est précédée de protected, et elle ne peut être utilisée qu’à l’intérieur de la classe,
    du paquetage, ou des classes dérivées.
    Paquetage : aucun mot particulier ne précède sa définition, ainsi la méthode peut être utilisé dans toute classe
    du même paquetage

Types

Le tableau ci-dessus recense les types de base, cependant il existe en Java d'autres types qui sont des objets
et sont à utiliser en tant que tel. Par exemple pour définir un entier on peut utiliser le type 'Integer' dont
la valeur d'initialisation par défaut vaudra null

Pour instancier une variable, la syntaxe (ici la même qu'en C) est la suivante :

NomDuType maVariable;

maVariable est alors allouée sur la pile.
Les collections d'objets

Il est souvent nécessaire de stocker de nombreuses données dans des collections : liste d’achats, notes des élèves, etc.
Les collections peuvent être consultées, modifiées, on peut les trier, les recopier, les supprimer, etc.
Elles peuvent avoir une taille fixe ou variable.

Les collections à taille fixe sont moins lourdes que les collections à taille variable.
Collections de taille fixe

    Les tableaux :

    Comme en C, les indices d'un tableau de taille n vont de 0 à n-1. Un des plus grands avantages des tableaux est
    l’accès en temps constant O(1), à chaque case du tableau.
    Les tableaux sont des objets en Java. Pour initialiser un tableau tab d’entiers de 10 cases,
    on peut écrire (entre autres) :

int[] tab = new int[10];

    ou :

int tab[] = new int[10];

    ou :

int tab[] = {0, 0, 0, 0, 0,
    0, 0, 0, 0, 0};

    Les indices de tab vont de 0 à 9, et il ne pourra pas être redimensionné.
    Chaque élément de tab est initialisé à sa valeur par défaut, ici 0 car il s'agit d'un tableau d'entiers (int).
    La valeur par défaut d'un objet est null, celle d'un booléen est false.

    Pour lire ou modifier l'élément de tab d'indice i, pour 0 ≤ i ≤ 9, on utilise tab[i].

        Exemple : Pour attribuer la valeur 2 à une case de tab, on écrit : tab[i] = 2;

    La propriété length (exemple : tab.length) fournit le nombre d'éléments du tableau. Si on essaie de modifier
    un élément qui n’existe pas, par exemple avec tab [10] = 4;, une exception IndexOutOfBoundsException est déclenchée
    (notre tableau tab ne contient que 10 cases, numérotées de 0 à 9 inclus).

Collections de taille variable

La classe abstraite AbstractList est fournie pour implémenter les collections à taille variable.

Pour initialiser une ArrayList il faut importer la classe java.util.ArrayList et écrire liste = new ArrayList<T>();
ou liste = new ArrayList<>(); depuis le JDK 7.0.

Depuis le JDK 1.5, on a la possibilité d’indiquer le type des éléments contenus dans une ArrayList : Entiers,
chaînes de caractères ou autres objets.

    Cette collection est vide après l’appel du constructeur ;
    On peut ajouter autant d’éléments que l’on veut.

Pour ajouter un élément on écrit liste.add(Objet);

Pour accéder à un élément de l’ArrayList : liste.get(index);

Pour connaître le nombre d’éléments que contient une liste : liste.size();

Pour supprimer un élément : liste.remove(index); les éléments qui suivent l’élément supprimé seront décalés à gauche.
Structures de contrôle
Boucles

Bien qu’elles aient toutes un rôle similaire, chaque boucle est pourtant adaptée à une situation :

    Structure tant que (adaptée pour effectuer des opérations tant qu’une condition est remplie) :

 while (<expression booléenne>) {
 	instruction(s)
 }

    Structure faire … tant que (comme la structure tant que mais la première itération est exécutée quelle que soit
    la condition, pour les autres itérations la condition doit être remplie) :

 do {
    instruction(s)
 }
 while (<expression booléenne>);

    Structure pour (adaptée lorsqu'une collection doit être parcourue en totalité pour traitement) :

 for (<initialisation> ; <condition de poursuite> ; <expression d’incrémentation>) {
    instruction(s)
 }

    Structure pour chaque (simplification du for en for each, dans laquelle l'expression doit être
    un tableau ou une collection) :

 for (type variable : <expression>) {
    instruction(s)
 }

    Structure pour (Java 1.5) :

 for (<Objet récupérant l’occurrence suivante de la collection> : <collection d’objets>) {
    instruction(s)
 }

Structures conditionnelles

    Structure si : condition simple

 if (<expression booléenne>) {
    instruction(s)
 }


Remarque : il est possible de combiner des conditions (expressions booléennes) en utilisant
des opérateurs supplémentaires : le « ET » logique && (instruction exécutée si toutes les conditions sont vraies) :

if (<condition 1> && <condition  2>) {
    instruction(s) si les conditions 1 et 2 sont vraies
}

Il existe aussi le « OU » logique || (instruction exécutée si au moins une des conditions est vraie) :

if (<condition 1> || <condition 2>) {
    instruction(s) si au moins une des deux est vraie
}

Enfin, il y a le « NON » logique ! qui permet d'inverser le résultat d'une condition.

Il est possible de combiner ces opérations pour obtenir des structures conditionnelles complexes. On peut ajouter
des parenthèses pour définir les priorités des conditions (comme dans un calcul). Dans les autres cas,
la JVM effectue les différentes vérifications de gauche à droite.


    Structure si … sinon : condition avec alternative unique

 if (<expression booléenne>) {
     instruction(s)
 }
 else {
     instruction(s)
 }

    Structure si … ou si … ou si … : condition avec alternatives multiples

 if (<expression booléenne>) {
     instruction(s)
 }
 else if (<expression booléenne>) {
     instruction(s)
 }
 else if (<expression booléenne>) {
     instruction(s)
 }
 else {
     instruction(s)
 }

    Structure atteindre … cas x … cas y … : embranchement vers un bloc d’instructions énuméré.

 switch (<expression>) {
    case <constante>:
         instruction(s)
         break;
    case <constante>:
        instruction(s)
        break;
    [...]
    default:
         instruction(s)
         break;
 }

Le choix d'exécution des instructions est déterminé par l'expression suivant switch dont le type peut être
entier (int, char, byte ou short ou classes enveloppes correspondantes), énuméré (enum) ou
String (chaîne de caractères, depuis Java 7 seulement).

Remarque :' Lopérateur conditionnel ou opérateur ternaire ? : peut permettre d'éviter l'utilisation
d'une instruction conditionnelle. Une expression conditionnelle aura l'une ou l'autre valeur après test de
la condition booléenne :

 <expression booléenne> ? <valeur si vrai> : <valeur si faux>

Branchements inconditionnels

    L'instruction break fait sortir immédiatement de la boucle en cours (for, while, do),
    mais permet également de sortir d’une clause contenue dans un switch. Si le break est omis,
    l'exécution du switch se poursuit de case en case.
    L'instruction continue termine l’itération en cours et continue à la prochaine.
    Son usage ainsi que celui de break dans les boucles est controversé
    (de la même manière que goto dans d'autres langages structurés).
    Elle tendrait à favoriser un type de programmation non structurée (programmation spaghetti).
    L’instruction return termine une méthode. Avec return uneValeur, uneValeur sera renvoyée à la méthode appelante.

Traitement des exceptions

 try {
       instruction(s)
 }
 catch (<type exception> <variable>) {
       instruction(s)
 }
 [...]
 finally {
       instruction(s)
 }

Le bloc de code finally sera exécuté quel que soit le résultat lorsque le programme sortira du bloc try-catch.

Voici un exemple de capture d’une exception :


 FileOutputStream fos = null;

 try {
      //Chacune de ces deux instructions peut générer une exception
      // création d'un flux pour écrire dans un fichier
      fos = new FileOutputStream(...);
      // écriture de données dans ce flux
      fos.write(...);
 }
 catch (IOException e) {
      //Gestion de l'erreur de création ou d'écriture dans le flux
      e.printStackTrace();
 }
 finally{
     //Cette section de code est toujours exécutée, qu’il y ait une exception ou pas
     // fermeture du flux s'il a été ouvert
     if(fos != null) fos.close();
 }

Cet exemple permet d’illustrer le mécanisme des exceptions en Java. Dans le cas d’une erreur d’entrée/sortie dans
le bloc try, l’exécution reprend dans le bloc catch correspondant à cette situation (exception de type IOException).

Dans ce bloc catch, la variable e référence l’exception qui s’est produite. Ici, nous invoquons
la méthode printStackTrace() qui affiche dans la console des informations sur l’exception qui s’est produite :
nom, motif, état de la pile d’appels au moment de la levée de l’exception et, éventuellement, numéro de ligne auquel
l’erreur s’est produite.

Le bloc finally est ensuite exécuté (ici pour refermer les ressources utilisées). Il ne s’agit ici que d’un exemple,
l’action à mettre en œuvre lorsqu’une exception survient dépend du fonctionnement général de l’application et de
la nature de l’exception.
Types génériques

Un type générique est autrement appelé un Template, il prend un ou plusieurs autres types en arguments.
Le type passé en paramètre est déterminé lors de l'instanciation.

Cela permet notamment dans le cadre des ArrayList d'éviter les transtypages.

 public class ArrayList<E> {
    ArrayList<String> al = new ArrayList<String>();
 }

Ces types génériques ne sont utilisés qu'à la compilation, et non directement dans le bytecode.

Différence avec le C++ : les templates en C++ dupliquent une classe pour chaque type. Java, au contraire,
agit au moment de la compilation comme si on avait dupliqué les classes de ces types intrinsèques mais ne traite en
réalité qu'avec une seule classe.
Codage du code source

Les spécifications du langage Java précisent qu’il est formé de caractères au format UTF-16, ce qui permet
l’utilisation dans le code source de tous les caractères existant dans le monde :

 public class HelloWorld {
    private String text = "hello world";
 }

Pour assurer la portabilité entre plates-formes, les noms de classes devraient néanmoins être formés uniquement
de caractères ASCII.

Opérateur de comparaison

Opérateur 	Signification
== 	Égal (ne pas confondre avec = qui est l'opérateur d'assignation)
!= 	Différent
< 	Inférieur
> 	Supérieur
<= 	Inférieur ou égal
>= 	Supérieur ou égal
Environnements de développement
JavaStyle

Les JavaStyle sont des conventions de programmation en langage Java définies par Sun.
Le respect de conventions strictes assure une homogénéité dans le code source d’une application développée par toute
une équipe et favorise la diffusion du code source auprès d’une communauté partageant les mêmes conventions de codage.

Le lower camel case est utilisé pour les noms de méthodes et de variables.
Frameworks et API

Sun fournit un grand nombre de frameworks et d’API afin de permettre l’utilisation de Java pour
des usages très diversifiés.

On distingue essentiellement quatre grands frameworks :

    Java SE (anciennement J2SE) : Ce framework est destiné aux applications pour poste de travail ;
    Java EE (anciennement J2EE) : Ce framework est spécialisé dans les applications serveurs.
    Il contient pour ce faire un grand nombre d’API et d’extensions ;
    Java ME (anciennement J2ME) : Ce framework est spécialisé dans les applications mobiles ;
    JavaFX (à ne pas confondre avec JavaFX) : Ce framework est spécialisé dans les applications liées
    aux cartes à puces et autres SmartCards. Il recouvre notamment l'ancien Java Card.

La persistance est fondée sur les standards :

    JDBC (Java DataBase Connectivity) ;
    JDO (Java Data Objects) ;
    EJB (Enterprise Java Beans).

On trouve toutefois de nombreuses autres technologies, API et extensions optionnelles pour Java :

    Java Media Framework (en) : framework multimédia, contenant notamment les API Java2D, Java 3D,
    JavaSound, Java advanced Imaging ;
    Java Telephony API (en) ;
    Java TV (en) ;
    JXTA : Système de peer-to-peer reposant sur Java ;
    Jini ;
    JAIN ;
    Java Dynamic Management Kit (en) (JMDK) ;
    JavaSpeech ;
    JMI ;
    JavaSpaces.

Outils de développement

La programmation peut se faire depuis une invite de commande en lançant un compilateur Java (souvent nommé javac),
mais pour avoir plus de confort, il est préférable d’utiliser un environnement de développement intégré ou
IDE (qui permet de compiler automatiquement), certains sont gratuits. Par exemple :

    BlueJ ;
    CodeWarrior ;
    Eclipse ;
    IntelliJ IDEA ;
    JBuilder ;
    JCreator ;
    jDeveloper 2 ;
    NetBeans .

Automatisation

Un programme Java peut être produit avec des outils qui automatisent le processus de construction
(c'est-à-dire l'automatisation de certaines tâches faisant appel à un nombre potentiellement grand de dépendances comme
l'utilisation de bibliothèques, la compilation, la génération d'archives, de documentation, le déploiement, etc.).
Les plus utilisés sont :

    Apache Ant (génération portable, décrite en XML) ;
    Apache Maven (génération portable, décrite en XML) ;
    Gradle (génération portable, en utilisant le langage Groovy) ;
    SCons (génération portable, en utilisant le langage Python). Exemple :

Java(target = 'classes', source = 'src')
      Jar(target = 'test.jar', source = 'classes')

Résultats :

     % scons -Q
     javac -d classes -sourcepath src src/Exemple1.java src/Exemple2.java src/Exemple3.java
     jar cf test.jar classes